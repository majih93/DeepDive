# 42장 비동기 프로그래밍

## 42.1 동기 처리와 비동기 처리

함수를 호출하면 함수 코드가 `평가`되어 `함수 실행 컨텍스트`가 생성 -> 생성된 `함수 실행 컨텍스트`는 `실행 컨텍스트 스택(=== 콜스택)`에 push되고, 함수 코드가 실행됨 -> 함수 코드의 실행이 종료되면 함수 실행 컨텍스트는 실행 컨텍스트 스택에서 pop 되어 제거

자바스크립트 엔진은 단 하나의 실행 컨텍스트 스택만을 가진다.(한 번에 하나의 작업만 실행할 수 있는 single thread 방식으로 동작하기 때문에)

즉 특정 시점에 자바스크립트 엔진이 실행하고 있는 동작은 실행 컨텍스트 스택 최상위에 위치한 작업 뿐이다. 만약 특정 작업이 일정 시간이 걸린다면, 한 번에 하나의 작업만을 수행할 수 있기 때문에 블로킹이 발생한다.

현재 진행되는 작업이 완료될 때 까지 다음 작업이 대기하는 방식을 `동기처리(Syncronous)`라고 한다. 동기 처리 방식은 들어온 순서대로 처리하므로 실행 순서가 보장된다는 장점이 있지만, 앞선 작업이 끝날 때까지 모든 작업이 중단되는 단점이 있다.

```javascript
// 자바스크립트 엔진이 싱글 스레드 방식으로 동작하기 때문에, 실행 컨텍스트에서 일정 시간이 걸리는 작업이 수행되고 있다면 다음 코드의 실행이 막히는 블로킹을 살펴보자
function executeFuncAfterDelay(func, delay) {
  // Date.now()는 현재 시간을 ms 로 반환 -> delay를 ms 단위로 추가해주면?
  const delayUntil = Date.now() + delay;

  // 현재 시간이 (현재 시간 + 더한 시간)보다 작을 경우 반복되는 while 문
  while (Date.now() < delayUntil);
  // 즉 전달된 콜백함수 func는 delay만큼의 시간이 흐른 후에 실행된다.
  func();
}

function foo() {
  console.log("foo");
}

function bar() {
  console.log("bar");
}

executeFuncAfterDelay(foo, 3 * 1000);

bar();

// 3초 경과 후 foo 찍힘 -> bar 찍힘
```

위 함수를 setTimeout 메서드를 활용해서 구현해보자.

```javascript
function foo() {
  console.log("foo");
}

function bar() {
  console.log("bar");
}

// setTimeout(callbackFunction, delayTime) -> delayTime이 지난 후에 callbackFunction을 실행
setTimeout(foo, 3 * 1000);
bar();

// 똑같은 결과가 나올거같은데 웬일? 이번에는 bar 가 먼저 출력되고 그 다음에 3초 뒤에 foo 가 출력됨
```

setTimeout 함수의 경우, 앞선 경우의 executeFuncAfterDelay와 비슷하게 동작하지만, setTimeout 함수의 실행 컨텍스트 다음 순서에 실행되는 코드는 setTimeout 함수의 호출완성 및 콜스택에서의 pop을 기다리지 않고 먼저 실행되고 pop된다. 이처럼 현재 실행 중인(or 실행 중인 것처럼 보이는, 먼저 콜스택에 들어갔지만 시간이 걸리는 작업) 작업이 종료되지 않은 상태라 해도 바로 다음 작업을 실행하는 방식을 비동기 처리 방식이라고 한다. **ASYNCHRONOUS**

동기 처리 방식과는 반대로, 비동기 처리 방식은 블로킹이 발생하지 않지만 작업의 실행 순서가 보장되지 않는다는 단점이 있다.

전통적으로 비동기 처리를 수행하기 위한 비동기 함수는 콜백 패턴을 활용했다. 하지만 이는 콜백 헬이라는 여러 콜백 함수의 중첩으로 이어지기 쉬웠다.

setTimeout/setInterval, HTTP 요청, 이벤트 핸들러는 비동기 처리 방식으로 동작한다.
-> _HTTP 요청이란? 이라는 질문에 답할 수 없다.. 그리고 비동기 처리 방식으로 동작하는 이벤트 핸들러의 예시를 대보라고 하면 그것도 하나도 모르겠다.ㅠ_

## 42.2 이벤트 루프와 태스크 큐

앞서 말했듯이, 자바스크립트 엔진 자체적으로는 싱글 스레드 방식으로 동작하기 때문에 한 번에 여러 가지 작업을 수행하는 것이 불가능하다. 하지만, 웹사이트를 보면 흔하게 여러 작업이 동시에 이루어지는 것을 볼 수 있다.

_최근에 내가 가장 골치아프게 생각하는 작업 중 하나인 API 호출도 서버에 요청을 보내 데이터를 받아오면서, 동시에 UI를 렌더링하는 방식으로 동작한다._

자바스크립트를 통해서 브라우저에서 이런 동시성을 가능케 해주는 것이 바로 `이벤트 루프` 이다

대부분의 자바스크립트 엔진은 크게 2개의 영역으로 구분된다.

**콜스택**
소스코드 평가 과정에서 생성된 실행 컨텍스트가 추가되고 제거되는 스택 자료구조인 실행 컨텍스트 스택

**힙(heap)**

객체가 저장되는 메모리 공간(원시 값도 객체인 실행 컨텍스트에 저장되어 저장, 즉 자바스크립트의 모든 값은 객체로 힙에 저장된다고 볼 수 있다.) 실행 컨텍스트는 힙에 저장된 객체를 참조한다. 메모리에 값을 저장하려면, 우선 해당 값이 저장될 메모리 공간의 크기를 결정해야한다. 객체는 그 크기가 정해져있지 않기 때문에 할당해야할 메모리 공간의 크기를 런타임에 결정해야한다(동적 할당). 값이 모두 객체로 저장되는 메모리 공간인 힙은 이런 이유로 구조화 되어 있지 않다는 특징이 있다.

콜스택 + 힙으로 구성된 자바스크립트 엔진은 자동차 엔진과 다를게 없다. `연료 투입 - 점화 - 폭발 - 배출` 같은 일련의 과정을 수행하는 자동차 엔진처럼 자바스크립트 엔진도 작업이 요청되면 이를 콜 스택에 push 하고, 콜 스택 최상단에 있는 작업부터 순차적으로 실행하는 작업만을 수행한다. 즉, 비동기 처리를 가능케 해주는 핵심 메커니즘은 자바스크립트 엔진이 아니라, 엔진이 동작하는 구동환경에 있을 수 밖에 없다. 아니 있다. 즉 브라우저 혹은 Node.js 가 비동기 처리에 필요한 작업을 담당해주는 것이다.

앞서 보았던 setTimeout 함수 실행 컨텍스트 내에 있는 소스코드의 평가와 실행은 자바스크립트 엔진이 한다. 하지만, 해당 함수 내 소스코드가 언제 실행될지는 브라우저/Nodejs 가 담당해서 처리한다. 이것을 가능케 해주는 브라우저 환경이 `태스크 큐`와 `이벤트 루프`이다.

**태스크 큐 task queue/event queue/callback queue**

비동기 함수의 콜백 함수나 이벤트 핸들러가 일시적으로 보관되는 영역이다. 테스크 큐와는 별도로 `Promise`의 후속 처리 메서드(어떤? then, catch 이런 메서드 말하는걸까?)의 콜백 함수가 일시적으로 보관되는 `마이크로태스크 큐`라는 영역도 존재한다.

**이벤트 루프**
_`실행 컨텍스트 스택` 이라는 이름 자체가 설명해주는 바가 있구나_

이벤트 루프의 역할은 현재 `실행 컨텍스트 스택`에 실행 중인 실행 컨텍스트가 있는지, 그리고 `태스크 큐`에 대기 중인 함수가 있는지 반복해서 확인하는 것이다.

그러면 당연히 어떻게 동작할까?

이런 느낌으로 동작한다. `LOOP`라는 점

```javascript
if(callStackArray.length === 0 && TaskQueue.length >= 1) {
  TaskQueue.map(function => {
    TaskQueue.shift(function)
    callStackArray.push(function)
    // callStack으로 이동된 함수는 실행된다.
    callStackArray.pop(function)
  })
}
```

그러면 아래 예제는 브라우저 환경에서 어떻게 동작할까?

```javascript
function foo() {
  console.log("foo");
}
function bar() {
  console.log("bar");
}

setTimeout(foo, 0);

bar();
```

순차적으로 생각해보자.

1. 전역 코드 평가 -> 전역 실행 컨텍스트 생성 -> 콜스택에 push -> 전역 코드 실행

2. setTimeout 함수 호출 -> setTimeout 실행 컨텍스트가 생성 및 콜스택에 push -> setTimeout 함수 속 콜백 함수와 설정된 delay에 대한 타이머 설정이 `브라우저`에 의해 저장되고, setTimeout은 pop(콜백 함수는 콜 스택이 빌 때까지, 그리고 delay가 끝날 때까지 태스크 큐에 저장되어 대기)

3. bar 함수 호출(이 때, 브라우저에서 앞서 실행된 setTimeout에 의한 delay를 설정하고 만료를 기다리고 있다. 타이머가 만료되고, 콜스택이 비어있다면 콜백 함수(foo)를 `태스크 큐`에 추가한다.(`자바스크립트 엔진`이 다음 코드를 계속 실행하는 동안에, `브라우저`가 이 작업을 수행하는 병렬 처리 상태인 것 setTimeout의 경우, delay 가 `4ms`이하인 경우 `4ms`로 delay 가 설정된다. 즉 `자바스크립트 엔진`이 계속 다음 작업을 수행하는 동안, `브라우저`에 의해서 4ms 후에 setTimeout의 콜백 함수가 태스크 큐에 푸시되어 대기하게 되는 것이다.) -> bar 함수 실행 컨텍스트 생성 -> 콜스택에 push -> bar 함수 내 코드 실행되고 pop

4. 전역 코드 실행 종료 -> 전역 컨텍스트가 콜스택에서 pop -> 콜스택이 비었네?

5. 이벤트 루프가 계속 태스크큐 / 콜스택 상태를 확인하면서 `콜스택이 비어있고, 태스크 큐에 함수가 존재할 경우`에 태스크 큐에 있는 함수를 콜스택에 push 하는 작업을 수행중이다. 4번 실행단계에서 콜스택이 비어있고, 태스크 큐에는 setTimeout의 콜백 함수인 foo가 대기중인 상태이다. 이 foo는 이벤트 루프에 의해서 콜스택에 push 된다.

6. foo 함수 호출 -> foo 함수 실행 컨텍스트 생성 -> foo함수 내 작업 실행 -> foo 함수 콜스택에서 pop

7. 코드 실행 종료.

즉, 브라우저 환경에서 비동기 처리를 가능케 하는 메커니즘은 `자바스크립트 엔진` + `브라우저` 두 가지가 동시에, 즉 멀티 스레드 형태로 동작하는 것이다.

_비동기 함수는 말 그대로, 동기적으로 처리되지 않는 함수라는 것이네. 코드가 호출된 순서대로 실행되는 것이 동기인데, 비동기는 호출순서랑 실행 순서가 다르니까_
