# 원시값과 객체의 비교

## 공부하기에 앞서..

왜 11장을 공부하게 되었는지?
-> 스터디에서 useMemo/useCallback 관련된 내용을 발표하고자 공부해보았음. 공부하면서, 두 hook 모두 referential equality와 연관성이 있다는 것을 알게 됨. -> 도대체 referential equality가 어떤 의미가 있고, 왜 중요한지 궁금해짐. -> 찾아보다 보니 passed by value / passed by reference 라는 개념에 대해 알게 됨 -> 알아보니 결국, javascript의 원시값 vs 객체값(primitive type / reference type)개념으로 이어짐 -> 11장을 공부해야겠다는 생각이 들었음

자바스크립트가 제공하는 7가지 데이터 타입은 다음 두 가지로 분류됨

1. 원시 타입(primitive type)

- number, string, boolean, null, undefined, symbol

2. 객체 타입(reference type)

- 객체 타입(객체, 함수, 배열 등등)

원시 타입과 객체 타입은 어떤 차이가 있을까?
-> 크게 세 가지 측면에서 다르다

1. 원시 값은 변경불가능한 값(immutable) vs 객체는 변경 가능한 값(mutable)

2. 원시값을 변수에 할당하면, 변수(확보된 메모리 공간)에는 실제 값이 저장됨 vs 객체를 변수에 할당하면 변수에는 참조 값이 저장됨

3. 원시 값을 갖는 변수를 다른 변수에 할당하면 원시 값이 복사되어 할당(값에 의한 전달 passed by value) vs 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달(passed by reference)

```javascript
// passed by reference
const a = [1, 2, 3];

const b = a;

b[1] = 10;

// passed by value

let c = 10;

let d = c;

d = d + 10;

console.log(a, b); //  [1, 10, 3] [1, 10, 3]
console.log(c, d); //  10 20
```

원시값인 숫자를 할당받은 변수 c 의 경우, 변수 c를 d에 할당하면 c가 가진 원시값이 d에 저장된다. -> d 를 조작해도 c에 영향이 가지 않음

반대로, reference type에 해당되는 배열을 할당받은 a 의 경우, a를 b 에 할당하면 a에 저장되어 있는 배열주소에 대한 참조값이 b 에 저장된다. -> b를 조작하면, 같은 주소를 참조하는 a도 영향을 받는다.

## 11.1 원시 값

### 11.1.1 변경 불가능한 값

원시 타입의 값은 변경 불가능한 값 _immutable_ .
-> 한번 생성된 원시 값은 읽기 전용의 값으로서 변경될 수 없다

무슨소리일까? 원시 값을 할당한 변수에 값을 재할당할 수도 있는데 그러면 변하는거 아니야? 라는 생각이 들었음
-> '변수'는 값을 저장하기 위해 확보된 메모리 공간이고, 값은 변수(라고 쓰고 메모리 공간/그 공간을 식별하는 이름이라고 읽는다)에 저장되어 있는 데이터.(표현식이 평가되어 생성된 결과)(표현식 평가 등에 대해서 제대로 알 필요가 있을 듯하다. 5장 이어서 공부해보자)
-> immutable 하다는 것은, 변수 공간에 한번 저장된 원시 값 데이터는, 변경될 수 없다는 의미.('이 공간에 있는 데이터는 이것이다'라는 진술이 불변한다는 의미)
-> 그래서 읽기 전용의 값이라는 의미. 해당 공간은 다른 데이터로 바꿔서 할당하는 식으로 동작시킬 수가 없음. 그냥 그 공간에 무엇이 있는지 읽어서 활용하는 것만 가능하다.

그렇다면, 변수를 재할당하는 것은 값의 변경이 아니라 무엇이지?
-> 변수를 재할당하는 것은, 기존에 변수에 연결되어 있던 공간에서, 다른 공간으로 연결을 한다는 의미가 됨. a라는 메모리공간이 아니라 , b 라는 메모리 공간에 값을 다시 집어 넣고 변수는 해당 공간과 연결되어 있는 것이라고 생각하면 되겠다.

정리하자면, 원시값의 경우 다음과 같은 맥락에서 불변한다.

1. 처음에 변수에 다른 값을 할당하면, 해당 변수가 참조하는 공간에 존재하던 기존 값을 새로운 값으로 대체하는 것이 아닐까라고 생각함.
   -> 이게 아니라, 변수에 다른 값을 할당하면 새로운 메모리 공간을 확보하고, 새로운 공간에 다른 값을 저장한다. 그리고 변수는 기존에 참조하던 메모리공간에서, 새로운 메모리 공간 주소를 참조하도록 바뀌는 것

2. 원래 공간에 존재하던 원시 값은, 우리가 어떤 방법으로건 다시 해당 공간에 새로운 값을 의도적으로 주입하는 것이 불가능하다는 의미가 된다. **불변성을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없다** (아마, 변수가 삭제되거나, 해당 공간이 연결된 변수가 없거나 할때 garbage collection을 통해서 청소되지 않을까?) 해당 공간의 주소를 참조하는 변수를 활용해서, 그 공간안에 존재하는 원시값이 무엇인지 보거나, 이를 활용해서 다른 연산을 하는 등의 행위. 즉 **읽어들이는** 행위만 가능하다는 의미!!

### 11.1.2 문자열과 불변성

왜 문자열만 따로 다루지? 라는 생각이 들었다.
-> 문자열은 유사 배열 객체이면서 이터러블임. (이터러블..유사 배열 객체..아직 모름..) 하지만, 이런걸 몰라도 다음의 사실은 알 수 있다.

```javascript
// string은 배열처럼, 특정 문자에 접근하는 것이 가능함

let myName = "Fred";

console.log(myName[0]);
// F

// 하지만, string은 불변하는 원시값인데 배열의 원소는 변경할 수 있지 않아?

myName[2] = "a";
console.log(myName);
// Frad가 출력될 줄 알았어? 아니야~~ Fred가 출력됐지롱.

// 인덱스를 활용해서 문자열 내 특정 문자를 변경하려고 해도 변경되지 않지만, 그렇다고 해서 오류가 뜨지도 않는다.
```

이렇게, 문자열은 한 번 생성되면 배열처럼 각 문자에 접근할 수 있고 가져다가 활용할 수는 있지만, 특정 문자를 변경(함으로써 원래 값을 변경)하는 것은 불가능하다.(라기보다는 그렇게 동작하지 않는다가 더 맞는 표현이기도?) 이는, 내가 myName이라고 선언한 문자열이 의도치 않게 변경되는 것을 막아 데이터의 신뢰성을 보장해준다.

### 11.1.3 값에 의해 전달

위에서 봤던 예시처럼, 값에 의한 전달은 변수c(C라는 메모리 공간 참조)에 변수a(A라는 메모리 공간 참조)를 할당할 때 변수 a 가 참조하는 공간A를 보고, 그 공간안에 원시값이 있으면 해당 **값**을 복사해서 c가 참조하는 공간C에 할당한다는 의미임.

근데, 이렇게 보면 '값에 의한 전달' 이라는 말이 가장 정확한 표현이 아닐 수도 있겠다. 변수 a가 c에 전달하는 것은 자신의 공간 A에 담긴 원시값이 아니라, 자신이 참조하는 공간 A 이다. 그리고 c는 a를 통해서 원시값을 받는 것이 아니라, A에 대한 접근 주소를 받아서 그 안에 뭐가 있는지 볼 수 있게 되는 것이다.

하지만, c는 a를 통해서 A라는 공간에 접근해서, A라는 공간을 그대로 참조하는게 아니라 A라는 공간 속 원시값을 가져다가 자신이 새롭게 초기화해서 참조하는 C라는 영역에 넣고 C의 주소를 가지고 있다. 즉, A와 C는 서로 다른 공간이므로 각각 공간을 참조하는 a 와 c 는, c 가 a의 공간을 보고 값을 가져다 썼다 할지언정 서로 연결점이 없음. 그러므로 a/c 를 재할당하는 등 각각을 변경하는 행위는 다른 아이에게 영향이 **전혀 없다**. 아니 영향이 있을 수도 없고, 있어서도 안된다.

## 11.2 객체

> 객체는 프로퍼티의 개수가 정해져있지 않으며, 동적으로 추가되고 삭제할 수 있다.

이 말은, 객체의 크기를 자바스크립트 엔진이 사전에 예측해서 미리 필요한만큼의 공간을 확보하는 방식으로 동작하는 것이 불가능하다는 의미가 된다.(원시 값의 경우, 확보해야 할 메모리 공간의 크기가 사전에 정해져있음)

즉 원시 값과 필요한 메모리 공간이 정해지는 방식에서부터 차이가 있으므로, 다른 방식으로 동작하도록 설계되어 있다.(음 이 표현이 제일 적절하게 느껴진다. 불가능하다, 어렵다 라기 보다는, ~한 이유로, 이러한 방식으로 동작하도록 설계되어 있다가 대체적으로 맞는 표현으로 보임)

### 11.2.1 변경 가능한 값

1. 객체를 생성하고 관리하는 일은 매우 복잡하고, 비용도 많이 드는 일이다.
   -> 원시값처럼, 객체도 변경될 때마다 원본을 건드리지 않고 새롭게 생성한다면 신뢰성이야 확보되겠지만 그를 위해서 메모리 성능이 굉장히 나빠질 수도 있다.

즉 객체가 원시값과 다르게 동작하는 것, 객체는 변경이 가능한 것은 안전한 데이터 관리라는 측면에서 봤을 때 최선의 선택은 아니지만 메모리 성능을 고려해서 어쩔 수 없이 다르게 설계되어 있다고 보는게 맞을 듯 하다.

그리고 이런 설계로 인해 객체는 구조적인 단점이 존재할 수 밖에 없다. 원시 값은 해당 메모리 주소 안에 하나의 값만 존재하고 해당 메모리 주소가 연결된 변수를 여러개 만들 수 없으므로 하나의 메모리 공간에 연결된 식별자가 하나밖에 존재하지 않는다.

하지만 객체의 경우, 하나의 메모리 공간에 연결된 식별자가 여러개 일수 있다.

즉, 같은 공간을 공유하는 식별자 중 하나를 통해서 해당 공간에 있는 객체를 변경했을 때, 다른 식별자들도 영향을 받아 원하지 않는 결과를 보게 될 수 있다는 의미가 된다.
(객체를 할당한 변수(라고 쓰고 메모리 공간이라고 읽는)에는 해당 객체가 담겨있는 메모리 주소가 저장되어있고, 객체에 접근하게 되면 해당 메모리 주소를 통해서 객체에 접근하게 됨.)

근데 그러면, 참조에 의한 전달이나 값에 의한 전달이나 변수a를 변수b에 할당 했을 때, a가 가진 메모리 공간에 접근한다는 점은 똑같은거 아닌가?
-> 맞음. 메모리 공간 문을 딱 열고 들어갔을 때, 사용하고자 하는 값 자체가 들어있는지 아니면 사용하고자 하는 값이 들어있는 주소가 들어있는지의 차이임. 사실 값이 들어있는 주소도 해당 메모리 공간에 존재하는 하나의 '값'이라고 본다면, 자바스크립트에는 정확하게 얘기했을 때 '참조에 의한 전달'이라는 것은 없다고 할 수도 있겠다. 그 값이 실제 내가 가져다쓰고자 하는 값인지, 아니면 그 값이 들어있는 주소인지의 차이가 있을 뿐, 변수를 참조했을 때 그 공간에 있는 그 무언가를 가져다가 쓴다는 것은 동일하니까.

---

## 기타 내용

- 이제서야 함수도 객체다 라는 개념이 어느정도 와닿는 듯 하다...
